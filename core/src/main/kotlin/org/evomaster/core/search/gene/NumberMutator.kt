package org.evomaster.core.search.gene

import org.evomaster.core.search.service.AdaptiveParameterControl
import org.evomaster.core.search.service.Randomness
import org.evomaster.core.utils.NumberCalculationUtil
import java.math.BigDecimal
import java.math.RoundingMode
import kotlin.math.min
import kotlin.math.pow

object NumberMutator {

    /**
     * @return the maximum range of the [value] that can be changed based on
     * @param direction specified direction, >0 means + and <0 means -
     * @param min the lower bound of [value]
     * @param max the upper bound of [value]
     * @param value to be further modified
     */
    fun <N:Number> getRange(direction: Double, min: N, max: N, value : N): Long {
        return if (direction > 0)
            NumberCalculationUtil.calculateIncrement(value.toDouble(), max.toDouble()).toLong()
        else
            NumberCalculationUtil.calculateIncrement(min.toDouble(), value.toDouble()).toLong()
    }

    /**
     * mutate double/float number
     */
    fun <N: Number> mutateFloatingPointNumber(randomness: Randomness,
                                              sdirection: Boolean?,
                                              maxRange: Long? = null,
                                              apc: AdaptiveParameterControl,
                                              value: N, smin: N, smax: N, scale: Int?): N{

        val direction = when{
            smax == value -> false
            smin == value -> true
            else -> sdirection
        }

        val gaussianDelta = getGaussianDeltaWithDirection(randomness, direction)

        val range = maxRange?:getRange(gaussianDelta, smin, smax, value)

        var res = modifyValue(randomness, value.toDouble(), delta = gaussianDelta, maxRange = range, specifiedJumpDelta = GeneUtils.getDelta(randomness, apc, range),scale == null)

        if (scale != null && getFormattedValue(value, scale) == getFormattedValue(res, scale)){
            res += (if (gaussianDelta>0) 1.0 else -1.0).times(getMinimalDelta(scale, value)!!.toDouble())
        }

        return if (res > smax.toDouble()) smax
        else if (res < smin.toDouble()) smin
        else getFormattedValue(res as N, scale)
    }

    /**
     * @param randomness
     * @param sDirection specify a direction, null means that the direction would be decided at random
     * @return direction info generated by Gaussian
     *          < 0 means - modification
     *          > 0 means + modification
     */
    private fun getGaussianDeltaWithDirection(randomness: Randomness, sDirection: Boolean?) : Double{
        var gaussianDelta = randomness.nextGaussian()
        if (gaussianDelta == 0.0)
            gaussianDelta = randomness.nextGaussian()

        if (sDirection != null && ((sDirection && gaussianDelta < 0) || (!sDirection && gaussianDelta > 0))){
            gaussianDelta *= -1.0
        }

        return gaussianDelta
    }

    private fun modifyValue(randomness: Randomness, value: Double, delta: Double, maxRange: Long, specifiedJumpDelta: Int, precisionChangeable: Boolean): Double{
        val strategies = FloatingPointNumber.ModifyStrategy.values().filter{
            precisionChangeable || it != FloatingPointNumber.ModifyStrategy.REDUCE_PRECISION
        }
        return when(randomness.choose(strategies)){
            FloatingPointNumber.ModifyStrategy.SMALL_CHANGE-> value + min(1, maxRange) * delta
            FloatingPointNumber.ModifyStrategy.LARGE_JUMP -> value + specifiedJumpDelta * delta
            FloatingPointNumber.ModifyStrategy.REDUCE_PRECISION -> BigDecimal(value).setScale(randomness.nextInt(15), RoundingMode.HALF_EVEN).toDouble()
        }
    }

    /**
     * @return minimal delta if it has.
     * this is typically used when the precision is specified
     */
    fun <N: Number> getMinimalDelta(scale: Int?, value: N): N? {
        if (scale == null) return null
        val mdelta = 1.0/((10.0).pow(scale))
        return when (value) {
            is Double -> NumberCalculationUtil.valueWithPrecisionAndScale(mdelta, scale).toDouble() as N
            is Float -> NumberCalculationUtil.valueWithPrecisionAndScale(mdelta, scale).toFloat() as N
            else -> throw Exception("valueToFormat must be Double or Float, but it is ${value::class.java.simpleName}")
        }
    }

    /**
     * @return formatted value based on precision if it has
     */
    fun <N: Number> getFormattedValue(valueToFormat: N, scale: Int?) : N {
        if (scale == null)
            return valueToFormat
        return when (valueToFormat) {
            is Double -> NumberCalculationUtil.valueWithPrecisionAndScale(valueToFormat.toDouble(), scale).toDouble() as N
            is Float -> NumberCalculationUtil.valueWithPrecisionAndScale(valueToFormat.toDouble(), scale).toFloat() as N
            else -> throw Exception("valueToFormat must be Double or Float, but it is ${valueToFormat::class.java.simpleName}")
        }
    }

    fun mutateLong(value: Long, min: Long?, max: Long?, randomness: Randomness, apc: AdaptiveParameterControl): Long {

        //choose an i for 2^i modification
        val delta = GeneUtils.getDelta(randomness, apc, longDeltaRange(min, max))

        return mutateLong(value, min, max, delta, randomness)
    }

    fun mutateLong(value: Long, min: Long?, max: Long?, delta: Int, randomness: Randomness): Long {

        val sign = when {
            max != null && (value >= max || ((value + delta) > max)) -> -1
            min != null && (value <= min || ((value - delta) < min)) -> +1
            else -> randomness.choose(listOf(-1, +1))
        }

        return value + (sign * delta)
    }

    /**
     * calculate the delta based on [min] and [max] that is used for eg, mutation
     * note the delta is less than [Long.MAX_VALUE]
     */
    private fun longDeltaRange(min: Long?, max : Long?) : Long{
        return if (min != null || max != null){
            try{
                min(Long.MAX_VALUE, Math.subtractExact(max?: Long.MAX_VALUE, min?: Long.MIN_VALUE))
            }catch (e : ArithmeticException) {
                Long.MAX_VALUE
            }
        }else
            Long.MAX_VALUE
    }

    fun randomizeLong(value: Long, min: Long?, max: Long?, randomness: Randomness, forceNewValue: Boolean) : Long {

        /*
            if one of min or max is specified,
            we employ [randomness.randomizeBoundedIntAndLong] for randomizing long that is same as randomizing int
         */
        if (min != null || max != null){
            return randomness.randomizeBoundedIntAndLong(value, min?: Long.MIN_VALUE, max?: Long.MAX_VALUE, forceNewValue)
        }

        var k = if (randomness.nextBoolean(0.1)) {
            randomness.nextLong()
        } else if (randomness.nextBoolean(0.1)) {
            randomness.nextInt().toLong()
        } else {
            randomness.nextInt(1000).toLong()
        }

        while (forceNewValue && k == value) {
            k = randomness.nextInt().toLong()
        }

        return k
    }

    fun randomizeDouble(min: Double?, max: Double?, scale: Int?, randomness: Randomness): Double{
        var rand = randomness.nextDouble()
        if ((min != null || max != null) && ((rand < (min ?: Double.MIN_VALUE)) || (rand > (max ?: Double.MAX_VALUE)))){
            rand = randomness.nextDouble(min?:Double.MIN_VALUE, max?:Double.MAX_VALUE)
        }
        return getFormattedValue(rand, scale)
    }

}